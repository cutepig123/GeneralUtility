#include "StdAfx.h"
#include "KeyBoard.h"
#include "Display.h"
#include "../easyVM.h"
#include "../cpu/cpu.h"
#include "../cpu/Instruction.h"
#include <stdio.h>

//为了简便起见，这里采用了一个 耦合度不好但效率较好的方法
//按键消息从Display.cpp里的窗口函数里接收。
//如果想降低I/O设备之间的耦合度，可以用下进程内钩子的方法。


#define PRS_INSERT 0x8000
#define PRS_CapsLock 0x4000
#define PRS_NumLock 0x2000
#define PRS_SCOLLock 0x1000
#define ST_PAUSE 0x0800
#define ST_INSERT 0x0080
#define ST_CapsLock 0x0040
#define ST_NumLock 0x0020
#define ST_SCOLLock 0x0010
#define PRS_ALT 0x0008
#define PRS_CTRL 0x0004
#define PRS_LShift 0x0002
#define PRS_RShift 0x0001

char KeyBoardRomDate[]={
	0x20,0x00,					//键盘状态
	0x00,						//Alt+小键盘
	0x1e,0x00,0x1e,0x00,		//键盘缓冲区首址尾址
	0x00,0x00,0x00,0x00,		//键盘缓冲区，共32字节
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
};
char KeyBoardRomDate2[]={
	0x10,0x02
};

/*
char UpperCase[]={
	 0 ,0x1b,'!','@','#','$','%','^','&','*','(',')','_','+',0x08,0x09,
	'Q','W','E','R','T','Y','U','I','O','P','{','}',0x0d, 0 ,'A','S',
	'D','F','G','H','J','K','L',':','"','~', 0 ,'|','Z','X','C','V',
	'B','N','M','<','>','?', 0 ,'*', 0 ,' ', 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 ,'7','8','9','-','4','5','6','+','1',
	'2','3','0','.', 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
};
char LowerCase[]={
	 0 ,0x1b,'1','2','3','4','5','6','7','8','9','0','-','=',0x08,0x09,
	'q','w','e','r','t','y','u','i','o','p','[',']',0x0d, 0 ,'a','s',
	'd','f','g','h','j','k','l',';','\'','`', 0 ,'\\','z','x','c','v',
	'b','n','m',',','.','/', 0 ,'*', 0 ,' ', 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
};
char Ctrl[]={
	 0 ,0x1b, 0 , 0 , 0 , 0 , 0 ,0x1e, 0 , 0 , 0 , 0 ,0x1f, 0 ,0x7f,0x00,
	0x11,0x17,0x5,0x12,0x14,0x19,0x15,0x09,0x0f,0x10,0x1b,0x1d,0x0a, 0 ,0x01,0x13,
	0x04,0x06,0x07,0x08,0x0a,0x0b,0x0c, 0 , 0 , 0 , 0 ,0x1c,0x1a,0x18,0x03,0x16,
	0x02,0x0e,0x0d, 0 , 0 , 0 , 0 , 0 , 0 ,0x20, 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 ,0xe0,0xe0,0xe0, 0 ,0xe0, 0 ,0xe0, 0 ,0xe0,
	0xe0,0xe0,0xe0,0xe0, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
};
char Alt[]={
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,0x20, 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 ,0x07,0x08,0x09, 0 ,0x04,0x05,0x06, 0 ,0x01,
	0x02,0x03, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
	 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
};
*/

char CodeMap[][8]={
//	单键，ASCII，+SHIFT，ASCII，+CTRL，ASCII，+ALT，ASCII
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x01, 0x1B, 0x01, 0x1B, 0x01, 0x1B, 0x01, 0x00 },
	{ 0x02, 0x31, 0x02, 0x21, 0x00, 0x00, 0x78, 0x00 },
	{ 0x03, 0x32, 0x03, 0x40, 0x03, 0x00, 0x79, 0x00 },
	{ 0x04, 0x33, 0x04, 0x23, 0x00, 0x00, 0x7A, 0x00 },
	{ 0x05, 0x34, 0x05, 0x24, 0x00, 0x00, 0x7B, 0x00 },
	{ 0x06, 0x35, 0x06, 0x25, 0x00, 0x00, 0x7C, 0x00 },
	{ 0x07, 0x36, 0x07, 0x5E, 0x07, 0x1E, 0x7D, 0x00 },
	{ 0x08, 0x37, 0x08, 0x26, 0x00, 0x00, 0x7E, 0x00 },
	{ 0x09, 0x38, 0x09, 0x2A, 0x00, 0x00, 0x7F, 0x00 },
	{ 0x0A, 0x39, 0x0A, 0x28, 0x00, 0x00, 0x80, 0x00 },
	{ 0x0B, 0x30, 0x0B, 0x29, 0x00, 0x00, 0x81, 0x00 },
	{ 0x0C, 0x2D, 0x0C, 0x5F, 0x0C, 0x1F, 0x82, 0x00 },
	{ 0x0D, 0x3D, 0x0D, 0x2B, 0x00, 0x00, 0x83, 0x00 },
	{ 0x0E, 0x08, 0x0E, 0x08, 0x0E, 0x7F, 0x0E, 0x00 },
	{ 0x0F, 0x09, 0x0F, 0x00, 0x94, 0x00, 0xA5, 0x00 },
	{ 0x10, 0x71, 0x10, 0x51, 0x10, 0x11, 0x10, 0x00 },
	{ 0x11, 0x77, 0x11, 0x57, 0x11, 0x17, 0x11, 0x00 },
	{ 0x12, 0x65, 0x12, 0x45, 0x12, 0x05, 0x12, 0x00 },
	{ 0x13, 0x72, 0x13, 0x52, 0x13, 0x12, 0x13, 0x00 },
	{ 0x14, 0x74, 0x14, 0x54, 0x14, 0x14, 0x14, 0x00 },
	{ 0x15, 0x79, 0x15, 0x59, 0x15, 0x19, 0x15, 0x00 },
	{ 0x16, 0x75, 0x16, 0x55, 0x16, 0x15, 0x16, 0x00 },
	{ 0x17, 0x69, 0x17, 0x49, 0x17, 0x09, 0x17, 0x00 },
	{ 0x18, 0x6F, 0x18, 0x4F, 0x18, 0x0F, 0x18, 0x00 },
	{ 0x19, 0x70, 0x19, 0x50, 0x19, 0x10, 0x19, 0x00 },
	{ 0x1A, 0x5B, 0x1A, 0x7B, 0x1A, 0x1B, 0x1A, 0x00 },
	{ 0x1B, 0x5D, 0x1B, 0x7D, 0x1B, 0x1D, 0x1B, 0x00 },
	{ 0x1C, 0x0D, 0x1C, 0x0D, 0x1C, 0x0A, 0x1C, 0x00 },
	{ 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x1E, 0x61, 0x1E, 0x41, 0x1E, 0x01, 0x1E, 0x00 },
	{ 0x1F, 0x73, 0x1F, 0x53, 0x1F, 0x13, 0x1F, 0x00 },
	{ 0x20, 0x64, 0x20, 0x44, 0x20, 0x04, 0x20, 0x00 },
	{ 0x21, 0x66, 0x21, 0x46, 0x21, 0x06, 0x21, 0x00 },
	{ 0x22, 0x67, 0x22, 0x47, 0x22, 0x07, 0x22, 0x00 },
	{ 0x23, 0x68, 0x23, 0x48, 0x23, 0x08, 0x23, 0x00 },
	{ 0x24, 0x6A, 0x24, 0x4A, 0x24, 0x0A, 0x24, 0x00 },
	{ 0x25, 0x6B, 0x25, 0x4B, 0x25, 0x0B, 0x25, 0x00 },
	{ 0x26, 0x6C, 0x26, 0x4C, 0x26, 0x0C, 0x26, 0x00 },
	{ 0x27, 0x3B, 0x27, 0x3A, 0x00, 0x00, 0x27, 0x00 },
	{ 0x28, 0x27, 0x28, 0x22, 0x00, 0x00, 0x28, 0x00 },
	{ 0x29, 0x60, 0x29, 0x7E, 0x00, 0x00, 0x29, 0x00 },
	{ 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x2b, 0x5C, 0x2b, 0x7C, 0x2B, 0x1C, 0x2b, 0x00 },
	{ 0x2C, 0x7A, 0x2C, 0x5A, 0x2C, 0x1A, 0x2C, 0x00 },
	{ 0x2D, 0x78, 0x2D, 0x58, 0x2D, 0x18, 0x2D, 0x00 },
	{ 0x2E, 0x63, 0x2E, 0x43, 0x2E, 0x03, 0x2E, 0x00 },
	{ 0x2F, 0x76, 0x2F, 0x56, 0x2F, 0x16, 0x2F, 0x00 },
	{ 0x30, 0x62, 0x30, 0x42, 0x30, 0x02, 0x30, 0x00 },
	{ 0x31, 0x6E, 0x31, 0x4E, 0x31, 0x0E, 0x31, 0x00 },
	{ 0x32, 0x6D, 0x32, 0x4D, 0x32, 0x0D, 0x32, 0x00 },
	{ 0x33, 0x2C, 0x33, 0x3C, 0x00, 0x00, 0x33, 0x00 },
	{ 0x34, 0x2E, 0x34, 0x3E, 0x00, 0x00, 0x34, 0x00 },
	{ 0x35, 0x2F, 0x35, 0x3F, 0x00, 0x00, 0x35, 0x00 },
	{ 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x37, 0x2A, 0x37, 0x2A, 0x96, 0x00, 0x37, 0x00 },
	{ 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x39, 0x20, 0x39, 0x20, 0x39, 0x20, 0x39, 0x20 },
	{ 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x3B, 0x00, 0x54, 0x00, 0x5E, 0x00, 0x68, 0x00 },
	{ 0x3C, 0x00, 0x55, 0x00, 0x5F, 0x00, 0x69, 0x00 },
	{ 0x3D, 0x00, 0x56, 0x00, 0x60, 0x00, 0x6A, 0x00 },
	{ 0x3E, 0x00, 0x57, 0x00, 0x61, 0x00, 0x6B, 0x00 },
	{ 0x3F, 0x00, 0x58, 0x00, 0x62, 0x00, 0x6C, 0x00 },
	{ 0x40, 0x00, 0x59, 0x00, 0x63, 0x00, 0x6D, 0x00 },
	{ 0x41, 0x00, 0x5A, 0x00, 0x64, 0x00, 0x6E, 0x00 },
	{ 0x42, 0x00, 0x5B, 0x00, 0x65, 0x00, 0x6F, 0x00 },
	{ 0x43, 0x00, 0x5C, 0x00, 0x66, 0x00, 0x70, 0x00 },
	{ 0x44, 0x00, 0x5D, 0x00, 0x67, 0x00, 0x71, 0x00 },
	{ 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x47, 0x00, 0x47, 0x37, 0x77, 0x00, 0x00, 0x07 },
	{ 0x48, 0x00, 0x48, 0x38, 0x8D, 0x00, 0x00, 0x08 },
	{ 0x49, 0x00, 0x49, 0x39, 0x84, 0x00, 0x00, 0x09 },
	{ 0x4A, 0x2D, 0x4A, 0x2D, 0x8E, 0x00, 0x4A, 0x00 },
	{ 0x4B, 0x00, 0x4B, 0x34, 0x73, 0x00, 0x00, 0x04 },
	{ 0x4C, 0x00, 0x4C, 0x35, 0x8F, 0x00, 0x00, 0x05 },
	{ 0x4D, 0x00, 0x4D, 0x36, 0x74, 0x00, 0x00, 0x06 },
	{ 0x4E, 0x2B, 0x4E, 0x2B, 0x90, 0x00, 0x4E, 0x00 },
	{ 0x4F, 0x00, 0x4F, 0x31, 0x75, 0x00, 0x00, 0x01 },
	{ 0x50, 0x00, 0x50, 0x32, 0x91, 0x00, 0x00, 0x02 },
	{ 0x51, 0x00, 0x51, 0x33, 0x76, 0x00, 0x00, 0x03 },
	{ 0x52, 0x00, 0x52, 0x30, 0x92, 0x00, 0x00, 0x00 },
	{ 0x53, 0x00, 0x53, 0x2E, 0x93, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
	{ 0x57, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00 },
	{ 0x58, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00 }
};

char MoveKeyCode[][8]={
	{ 0x47, 0xE0, 0x47, 0xE0, 0x77, 0xE0, 0x97, 0x00 },
	{ 0x48, 0xE0, 0x48, 0xE0, 0x8D, 0xE0, 0x98, 0x00 },
	{ 0x49, 0xE0, 0x49, 0xE0, 0x84, 0xE0, 0x99, 0x00 },
	{ 0x4B, 0xE0, 0x4B, 0xE0, 0x73, 0xE0, 0x9B, 0x00 },
	{ 0x4D, 0xE0, 0x4D, 0xE0, 0x74, 0xE0, 0x9D, 0x00 },
	{ 0x4F, 0xE0, 0x4F, 0xE0, 0x75, 0xE0, 0x9F, 0x00 },
	{ 0x50, 0xE0, 0x50, 0xE0, 0x91, 0xE0, 0xA0, 0x00 },
	{ 0x51, 0xE0, 0x51, 0xE0, 0x76, 0xE0, 0xA1, 0x00 },
	{ 0x52, 0xE0, 0x52, 0xE0, 0x92, 0xE0, 0xA2, 0x00 },
	{ 0x53, 0xE0, 0x53, 0xE0, 0x93, 0xE0, 0xA3, 0x00 }
};

unsigned short *KbState,*KbBufHead,*KbBufTail;
int ts;
UINT msg,premsg;								//接键消息会设置BlobINT，并且会填充这三个值，中断处理程序会读取这三个值。
WPARAM wParam;
LPARAM lParam,prelParam;


//判断一个键是否会被放入缓冲区
bool BufKey(unsigned char scanCode)
{
	switch(scanCode)
	{
	case 0x3a:
	case 0x45:
	case 0x46:
	case 0x2a:
	case 0x36:
	case 0x38:
	case 0x1d:
	case 0x37:
		return false;
	default:
		return true;
	}
}

void IncPnt(unsigned short *pnt)
{
	*pnt=((*pnt+1)-0x1e)%0x20+0x1e;
}

void DecPnt(unsigned short *pnt)
{
	*pnt=((*pnt-1)-0x1e+0x20)%0x20+0x1e;
}

bool ProcessSpecialKey(UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch(wParam)
	{
	case VK_CAPITAL:
	case VK_NUMLOCK:
	case VK_SCROLL:
	case VK_INSERT:
	case VK_SHIFT:	
	case VK_MENU:
	case VK_CONTROL:
	case VK_PAUSE:
		RefreshKeyboardState();
		return true;
		break;
	case VK_UP:
	case VK_DOWN:
	case VK_LEFT:
	case VK_RIGHT:	
	case VK_HOME:
	case VK_PRIOR:
	case VK_DELETE:
	case VK_END:
	case VK_NEXT:
		if (lParam&0x1000000)				//不在小键盘上的特殊键
		{		
			if ((*KbState)&PRS_ALT)								//同时按下了Alt键
				*(unsigned char *)(0x400+(*KbBufTail)+MemoryStart)=MoveKeyCode[((lParam>>16)&0xff)-0x47][7];
			else if ((*KbState)&PRS_CTRL)						//同时按下了Ctrl键
				*(unsigned char *)(0x400+(*KbBufTail)+MemoryStart)=MoveKeyCode[((lParam>>16)&0xff)-0x47][5];
			else if ((((*KbState)&PRS_LShift) || ((*KbState)&PRS_RShift)))
				*(unsigned char *)(0x400+(*KbBufTail)+MemoryStart)=MoveKeyCode[((lParam>>16)&0xff)-0x47][3];
			else
				*(unsigned char *)(0x400+(*KbBufTail)+MemoryStart)=MoveKeyCode[((lParam>>16)&0xff)-0x47][1];
			IncPnt(KbBufTail);
			*(unsigned char *)(0x400+(*KbBufTail)+MemoryStart)=(lParam>>16)&0xff;
			IncPnt(KbBufTail);
			return true;
		}
		break;
	}
	return false;
}

void IO_Write_0059()						//键盘的中断处理程序，即INT 9
{

}

void IO_Read_0064()
{
	eCPU.al=0x10;
}

unsigned char ScanToAscii(unsigned char scanCode,unsigned char virtualKey)
{
	unsigned char ascii;
	if ((*KbState)&PRS_ALT)								//同时按下了Alt键
		ascii=CodeMap[scanCode][7];
	else if ((*KbState)&PRS_CTRL)						//同时按下了Ctrl键
		ascii=CodeMap[scanCode][5];
	//上面已经处理了同时按下Alt或者Ctrl的情况，下面只处理一般的单键情况即可
	else if (wParam>=0x41 && wParam<=0x5a)							//受CapsLock影响
		if (!((*KbState)&ST_CapsLock) == !(((*KbState)&PRS_LShift) || ((*KbState)&PRS_RShift)))		//利用!号把短整型变成布尔型
			ascii=CodeMap[scanCode][1];
		else
			ascii=CodeMap[scanCode][3];
	else if(scanCode>=0x47 && scanCode<=0x53)			//受NumLock影响	箭头键和数字键共用相同的扫描码，所以要用virtualKey加以区别
	{
		if (virtualKey<0x60)							//箭头等键			
			ascii=0x0;
		else											//数字键盘
			if (((*KbState)&ST_NumLock) && !(((*KbState)&PRS_LShift) || ((*KbState)&PRS_RShift)))
				ascii=CodeMap[scanCode][3];
			else
				ascii=CodeMap[scanCode][1];
	}
	else												
		if ((((*KbState)&PRS_LShift) || ((*KbState)&PRS_RShift)))
			ascii=CodeMap[scanCode][3];
		else
			ascii=CodeMap[scanCode][1];
	return ascii;
}


//scancode应该在查表之后、传出去之前根据组合键修改
unsigned char FixScanCode(unsigned char old)
{
	unsigned char ans;
	if ((*KbState)&PRS_ALT)								//同时按下了Alt键
		ans=CodeMap[old][6];
	else if ((*KbState)&PRS_CTRL)						//同时按下了Ctrl键
		ans=CodeMap[old][4];
	else if ((((*KbState)&PRS_LShift) || ((*KbState)&PRS_RShift)))
		ans=CodeMap[old][2];
	else
		ans=CodeMap[old][0];
	return ans;
}

void RecvKeyBoardMsg(UINT rmsg, WPARAM rwParam, LPARAM rlParam)
{
	premsg=msg;
	msg=rmsg;
	wParam=rwParam;
	prelParam=lParam;
	lParam=rlParam;
	
	//键盘处理放在请求IRR中断之前，这样做就丧失了"禁键盘"的功能。以后改正！
	////////////////////////键盘处理/////////////////////////////
	unsigned char scanCode=(lParam>>16)&0xff;
	unsigned char virtualKey=wParam;
	if (msg==WM_KEYDOWN || msg==WM_SYSKEYDOWN)
	{	
		if (ProcessSpecialKey(msg,wParam,lParam))
			__asm nop
		else
		{	
			*(unsigned char *)(0x400+(*KbBufTail)+MemoryStart)=ScanToAscii(scanCode,virtualKey);			
			IncPnt(KbBufTail);
			scanCode=FixScanCode(scanCode);
			*(unsigned char *)(0x400+(*KbBufTail)+MemoryStart)=scanCode;
			IncPnt(KbBufTail);				
		}
	}
	else if (msg==WM_KEYUP || msg==WM_SYSKEYUP)
	{
		RefreshKeyboardState();
	}
	////////////////////////键盘处理/////////////////////////////

	IRR|=0x2;						//PIC的中断号是从8开始的，所以0x2是Int 9
}

void RefreshKeyboardState()
{
	unsigned short tks,tcs;
	tks=GetAsyncKeyState(VK_RSHIFT);
	//tks<<=0;
	tks>>=15;
	tcs=0x01;
	*KbState&=~tcs;
	*KbState|=tks;
	tks=GetAsyncKeyState(VK_LSHIFT);
	//tks<<=1;
	tks>>=14;
	tcs=0x02;
	*KbState&=~tcs;
	*KbState|=tks;
	tks=GetAsyncKeyState(VK_CONTROL);
	//tks<<=2;
	tks>>=13;
	tcs=0x04;
	*KbState&=~tcs;
	*KbState|=tks;
	tks=GetAsyncKeyState(VK_MENU);		//Alt键
	//tks<<=3;
	tks>>=12;
	tcs=0x08;
	*KbState&=~tcs;
	*KbState|=tks;	
	tks=GetKeyState(VK_SCROLL);
	tks<<=4;	
	tcs=0x10;
	*KbState&=~tcs;
	*KbState|=tks;
	tks=GetKeyState(VK_NUMLOCK);
	tks<<=5;	
	tcs=0x20;
	*KbState&=~tcs;
	*KbState|=tks;
	tks=GetKeyState(VK_CAPITAL);
	tks<<=6;	
	tcs=0x40;
	*KbState&=~tcs;
	*KbState|=tks;
	tks=GetKeyState(VK_INSERT);
	tks<<=7;	
	tcs=0x80;
	*KbState&=~tcs;
	*KbState|=tks;	
	tks=GetKeyState(VK_PAUSE);
	tks<<=11;	
	tcs=0x0800;
	*KbState&=~tcs;
	*KbState|=tks;
}

//用EDIT.com练习的时候，发现键盘发现太慢，如果打字太快会丢掉一些字。
//发现Bochs也有这种情况。应该是EDIT.com的问题。
void IO_Write_0016()
{
	unsigned char scanCode;
	unsigned char virtualKey;
	switch(eCPU.ah)
	{
	case 0:
	case 0x10:
		//while (*KbBufHead==*KbBufTail)
		virtualKey=wParam;
		while (msg==WM_KEYUP || msg==WM_SYSKEYUP || virtualKey==VK_SHIFT || virtualKey==VK_CONTROL || virtualKey==VK_MENU)
		{
			Sleep(10);						//为了使等待输入的时候不占太多CPU资源
		}
// 		eCPU.al=*(unsigned char *)(0x400+(*KbBufHead)+MemoryStart);
// 		IncPnt(KbBufHead);
// 		eCPU.ah=*(unsigned char *)(0x400+(*KbBufHead)+MemoryStart);
// 		IncPnt(KbBufHead);

		scanCode=(lParam>>16)&0xff;			//因为前面有Sleep过，期间按了键，所以不可以在Sleep前取scanCode
		virtualKey=wParam;
 		eCPU.al=ScanToAscii(scanCode,virtualKey);
		scanCode=FixScanCode(scanCode);
 		eCPU.ah=scanCode;
		if (BufKey(scanCode))
		{
			IncPnt(KbBufHead);
			IncPnt(KbBufHead);
		}

		prelParam=lParam;		
		msg=WM_KEYUP;						//一个WM_KEYDOWN或WM_SYSKEYDOWN只处理一次
		break;
	case 1:
	case 0x11:
		//fprintf(fDebug,"%x %x\t %x %x  %x %x\n",*KbBufHead,*KbBufTail,prelParam,lParam,premsg,msg);
		//if (*KbBufHead==*KbBufTail)
		virtualKey=wParam;
		if (msg==WM_KEYUP || msg==WM_SYSKEYUP || virtualKey==VK_SHIFT || virtualKey==VK_CONTROL || virtualKey==VK_MENU)
		{
			Sleep(1);						//在这里加一个Sleep可以非常有效地降低easyVM的CPU占用率！
			(*(unsigned short*)((ts=eCPU.ss,ts<<=4)+eCPU.sp+4+MemoryStart))|=ZF;
		}
		else
		{
 			(*(unsigned short*)((ts=eCPU.ss,ts<<=4)+eCPU.sp+4+MemoryStart))&=~ZF;
// 			eCPU.al=*(unsigned char *)(0x400+(*KbBufHead)+MemoryStart);
// 			IncPnt(KbBufHead);
// 			eCPU.ah=*(unsigned char *)(0x400+(*KbBufHead)+MemoryStart);
// 			DecPnt(KbBufHead);
			//因为Insert等键不入缓冲区，所以不能像上面那样写
			scanCode=(lParam>>16)&0xff;			//因为前面有Sleep过，期间按了键，所以不可以在Sleep前取scanCode
			virtualKey=wParam;
 			eCPU.al=ScanToAscii(scanCode,virtualKey);
			scanCode=FixScanCode(scanCode);
 			eCPU.ah=scanCode;
		}
		break;
	case 2:
		eCPU.al=*KbState;
		break;
	case 3:
		break;			//本键盘不支持设置重复率。（实际上可以SystemParametersInfo(SPI_GETKEYBOARDSPEED ,NULL,&d,0)这样设置，不过会影响整机，就算了。
	case 4:
		break;			//没看懂，什么是键盘点击功能
	case 5:
		*(unsigned char *)(0x400+*KbBufTail+MemoryStart)=eCPU.cl;
		IncPnt(KbBufTail);
		*(unsigned char *)(0x400+*KbBufTail+MemoryStart)=eCPU.ch;
		IncPnt(KbBufTail);
		break;
	}
}

void KeyBoardInit()
{	
	msg=WM_KEYUP;
	OutTable[0x0059]=(unsigned int)IO_Write_0059;
	memcpy((void *)(MemoryStart+0x417),KeyBoardRomDate,sizeof(KeyBoardRomDate));
	memcpy((void *)(MemoryStart+0x496),KeyBoardRomDate2,sizeof(KeyBoardRomDate2));	
	KbState=(unsigned short *)(MemoryStart+0x417);
	KbBufHead=(unsigned short *)(MemoryStart+0x41a);
	KbBufTail=(unsigned short *)(MemoryStart+0x41c);
	InTable[0x0064]=(unsigned int)IO_Read_0064;
	OutTable[0x0016]=(unsigned int)IO_Write_0016;
}