 <!DOCTYPE html><html><!--STATUS OK--> <head> <meta http-equiv=Content-Type content="text/html; charset=utf-8"> <title>算法导论相关最新内容_百度空间</title> <link rel="shortcut icon" href="http://hi.bdimg.com/static/qbase/img/mod/16_favicon.ico?v=49f19c7f.ico" type=image/x-icon>  <meta name=description content="最长连续公共子序列和最长连续子字符串(zz):  问题的关键还是如何定义子问题，假设有： Xm = x1 x2 x3 ... xm Yn = y1 y2 y3 ... yn 1. 最长公共子序列(不必连续) 定义f(m, n)为Xm和Yn之间最长的子序列的长度 于是有f(m, 0) = f(0, m) = 0 如果xm != yn, 则f(m, n) = max{ f(m-1, n), f(m, n-1) } 如果xm = yn，则f(m, n) = f(m-1, n-1) + 1 问题归结于求f(m, n)。依照公式用Bottom-up DP可解。 2. 最长连续子字符串(必须是连续的) 定义f(m, n)为Xm和Yn之间最长的子字符串的长度并且该子字符串结束于Xm &amp; Yn。因为要求是连续的，所以定义f的时候多了一个要求字符串结束于Xm &amp; Yn 于是有f(m, 0) = f(0, m) = 0 如果xm != yn, 则f(m, n) = 0 如果xm = yn, 则f(m, n) = f(m-1, n-1) + 1 因为最长字符串不一定结束于Xm / Yn末尾，所以这里必须求得所有可能的f(p, q) | 0 &lt; p &lt; m, 0 &lt; q &lt; n, 最大的f(p, q)就是解。依照公式用Bottom-up DP可解。 求最长公共子字符串可以使用前缀树http://en.wikipedia.org/wiki/Longest_common_substring 最长连续子字符串的代码如下： package org.java.cgcl; public class LCSS { public static int[][] comput_LCSS(String stra, String strb){ int[][] &nbsp; matrix = new int[stra.length()][]; for(int i = 0; i &lt; stra.length(); i++){ matrix[i] = new int[strb.length()]; } for(int i = 0; i &lt; stra.length(); i++){ for(int j = 0; j &lt; strb.length(); j++){ if(stra.charAt(i) == strb.charAt(j)){ "> <meta name=keywords content="算法导论"><script>window.wpo={start:new Date*1,pid:109,page:'qing'}</script><!--[if IE]><script type="text/javascript">(function(){var b=("abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video").split(","),a=b.length;while(a--){document.createElement(b[a])}})();</script><![endif]--><script fcpcompress>window.qDomain={"qing":"http://hi.baidu.com","static":"http://hi.bdimg.com","passport":"https://passport.baidu.com","portrait":"http://tx.bdimg.com","hiup":"http://hiup.baidu.com","photo":"http://hiphotos.baidu.com","message":"http://msg.baidu.com","friend":"http://frd.baidu.com","mp3":"http://mp3.baidu.com","ting":"http://ting.baidu.com","image":"http://img.baidu.com","qup":"http://hi.baidu.com","www":"http://www.baidu.com"};window.qUserInfo={"userName":"","portrait":"00000000","qingUrl":"\/","spaceName":"的空间","right":"0","avatarStatus":"","flagNeedInvite":"0","flagNotInvited":"1","version":"2"};window.qVisitorInfo={"userName":"","portrait":"","isHost": false,"loginStatus":"not_login","qingUrl":"","right":"0","version":"0"};window.qPageInfo={"pageUrl":"http:\/\/hi.baidu.com\/tag\/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA\/feeds","referUrl":"http:\/\/hi.baidu.com\/isswangqing\/item\/8e0908273e773d54c38d59bc"};window.qUserAvatar={size20:"",size40:"",size65:"",size110:"",size160:""};window.qVisitorAvatar={size20:"",size40:"",size65:"",size110:"",size160:""};window.qBdsToken="the fisrt two args should be string type:0,1!";window.qErrorInfo={"no":"0","msg":""};window.qServerInfo={"timeStamp":"1341077163"};window.qLongPolling={"url":"http:\/\/m.hi.baidu.com\/i\/msg\/listen"}</script><!--[if (lt IE 8.0)]><link href="http://hi.bdimg.com/static/qbase/css/qbase.css?v=463d0d8f.css" type=text/css rel=stylesheet><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link href="http://hi.bdimg.com/static/qbase/css/qbase_datauri.css?v=1d7bdc2d.css" type=text/css rel=stylesheet><!--<![endif]-->  <!--[if (lt IE 8.0)]><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment.css?v=b14d92dd.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment_datauri.css?v=9df19318.css"><!--<![endif]--><!--[if (lt IE 8.0)]><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcenter/css/qcenter.css?v=f227dba5.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcenter/css/qcenter_datauri.css?v=d3959f15.css"><!--<![endif]--><!--[if (lt IE 8.0)]><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qtag/css/qtag_show_feeds.css?v=c8580018.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qtag/css/qtag_show_feeds_datauri.css?v=7484e3c2.css"><!--<![endif]--> <script src="http://hi.bdimg.com/static/qbase/js/qing/qing.js?v=f02f1bdb.js"></script> <script src="http://hi.bdimg.com/static/qtag/js/boot_qtag_show_feeds.js?v=d7e71e6c.js"></script><script>		//初始化feed首屏数据		var firstFeedData = {"errorNo" : "0","errorMsg" : "","data": [ {id : '29463786',postedTime : '1329048107',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/mryuan0', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=5a7acdb809f79052eb4100617ccee1ff/8b82b9014a90f603095322ec3912b31bb151edbe.jpg', portrait : '77c26d727975616e303909', name : '袁大星' }, object : {type : 'text',id : '8681a89450c8b6b4cd80e5f2',url : 'http:\/\/hi.baidu.com\/mryuan0\/item\/8681a89450c8b6b4cd80e5f2',title : '最长连续公共子序列和最长连续子字符串(zz)',summary : '<p>问题的关键还是如何定义子问题，假设有：<\/p> <p>Xm = x1 x2 x3 ... xm<\/p> <p>Yn = y1 y2 y3 ... yn<\/p> <p>1. 最长公共子序列(不必连续)<\/p> <p>定义f(m, n)为Xm和Yn之间最长的子序列的长度<\/p> <p>于是有f(m, 0) = f(0, m) = 0<\/p> <p>如果xm != yn, 则f(m, n) = max{ f(m-1, n), f(m, n-1) }<\/p> <p>如果xm = yn，则f(m, n) = f(m-1, n-1) + 1<\/p> <p>问题归结于求f(m, n)。依照公式用Bottom-up DP可解。<\/p> <p>2. 最长连续子字符串(必须是连续的)<\/p> <p>定义f(m, n)为Xm和Yn之间最长的子字符串的长度并且该子字符串结束于Xm &amp; Yn。因为要求是连续的，所以定义f的时候多了一个要求字符串结束于Xm &amp; Yn<\/p> <p>于是有f(m, 0) = f(0, m) = 0<\/p> <p>如果xm != yn, 则f(m, n) = 0<\/p> <p>如果xm = yn, 则f(m, n) = f(m-1, n-1) + 1<\/p> <p>因为最长字符串不一定结束于Xm \/ Yn末尾，所以这里必须求得所有可能的f(p, q) | 0 &lt; p &lt; m, 0 &lt; q &lt; n, 最大的f(p, q)就是解。依照公式用Bottom-up DP可解。<\/p> <p>求最长公共子字符串可以使用前缀树http:\/\/en.wikipedia.org\/wiki\/Longest_common_substring<\/p> <p>最长连续子字符串的代码如下：<\/p> <p>package org.java.cgcl;<\/p> <p>public class LCSS {<\/p> <p>public static int[][] comput_LCSS(String stra, String strb){<\/p> <p>int[][] &nbsp; matrix = new int[stra.length()][];<\/p> <p>for(int i = 0; i &lt; stra.length(); i++){<\/p> <p>matrix[i] = new int[strb.length()];<\/p> <p>}<\/p> <p>for(int i = 0; i &lt; stra.length(); i++){<\/p> <p>for(int j = 0; j &lt; strb.length(); j++){<\/p> <p>if(stra.charAt(i) == strb.charAt(j)){<\/p> ',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '29463784',postedTime : '1329036824',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/mryuan0', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=5a7acdb809f79052eb4100617ccee1ff/8b82b9014a90f603095322ec3912b31bb151edbe.jpg', portrait : '77c26d727975616e303909', name : '袁大星' }, object : {type : 'text',id : 'dafab1d41bd7509c260ae7f2',url : 'http:\/\/hi.baidu.com\/mryuan0\/item\/dafab1d41bd7509c260ae7f2',title : 'Palindrome Number（一）',summary : '<p>Determine whether an integer is a palindrome. Do this without extra space.<\/p> <p>这个问题首先要弄清楚integer的表示方式，如果是一个char数组，直接从头尾遍历就可以了。<\/p> <p>如果是数字，负数，我们定义它不是回文数。<\/p> <p>如果是正数，我们首先考虑的是将它转化为string，然后利用上面的遍历就可以解决。<\/p> <p>但是题目要求不能使用额外的存储空间。<\/p> <p>下面介绍两种方法，很容易计算数字的最低位，我们可以依次获取数字的最低位，然后利用最低位组成一个十进制数字，这样就相当于将数字逆序了，然后比较两个数字的是否相等。<\/p> <p>另一种方法是依次计算数字的最高位（需要技巧）和最低位，然后比较两个数字是否相等。<\/p> <p>下面是代码：<\/p> <p>package org.java.cgcl;<\/p> <p>public class Palindrome {<\/p> <p>public &nbsp;static boolean test1palindrome(int inte){<\/p> <p>int save = inte;<\/p> <p>int reverse = 0;<\/p> <p>if(inte &lt; 0)<\/p> <p>return false;<\/p> <p>while(inte != 0){<\/p> <p>int tail = &nbsp;inte % 10;<\/p> <p>reverse = reverse * 10 + tail;<\/p> <p>inte \/= 10;<\/p> <p>}<\/p> <p>if(reverse == save){<\/p> <p>return true;<\/p> <p>}else{<\/p> <p>return false;<\/p> <p>}<\/p> <p>}<\/p> <p>public &nbsp;static boolean test2palindrome(int inte){<\/p> <p>if(inte &lt; 0){<\/p> <p>return false;<\/p> <p>}<\/p> <p>int k = 1;<\/p> <p>while(inte \/ k &gt; 10){<\/p> <p>k *= 10;<\/p> <p>}<\/p> <p>int left = k;<\/p> <p>int right = 10;<\/p> <p>int right_right = 1;<\/p> <p>while(left &gt; right_right){<\/p> <p>int first = (inte \/ left) % 10;<\/p> <p>int end = (inte % right) \/ right_right;<\/p> <p>if(first != end){<\/p> <p>return false;<\/p> ',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '944247',postedTime : '1325905974',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/taozpwater', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=c8284969fc039245a5eba650f7a992f7/b58f8c5494eef01f31cfa761e0fe9925bd317dbe.jpg', portrait : '287d74616f7a7077617465722809', name : 'taozpwater' }, object : {type : 'text',id : '969cd30ff9ab6bca2f4c6b7e',url : 'http:\/\/hi.baidu.com\/taozpwater\/item\/969cd30ff9ab6bca2f4c6b7e',title : 'BF（Brute Force）算法简介',summary : '<p>1、简介<\/p> <p>&nbsp; &nbsp; &nbsp;BF（Brute Force）算法核心思想是：首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；若S[1]和T[1]不等，则T向右移动一个字符的位置，再依次进行比较。如果存在k，1≤k≤N，且S[k+1…k+M]=T[1…M]，则匹配成功；否则失败。该算法最坏情况下要进行M*(N-M+1)次比较，时间复杂度为O(M*N)。<\/p> <p>2、代码<\/p> <p>#include&lt;iostream&gt;<\/p> <p>#include&lt;string.h&gt;<\/p> <p>using namespace std;<\/p> <p>#define N 80<\/p> <p>void main()<\/p> <p>{<\/p> <p>&nbsp; &nbsp; char S[N],T[N];<\/p> <p>&nbsp; &nbsp; int i,j,count=0;<\/p> <p>&nbsp; &nbsp; cout&lt;&lt;&quot;请输入长串S:&quot;;<\/p> <p>&nbsp; &nbsp; gets(S);<\/p> <p>&nbsp; &nbsp; cout&lt;&lt;&quot;请输入子串T:&quot;;<\/p> <p>&nbsp; &nbsp; gets(T);<\/p> <p>&nbsp; &nbsp; i=0;j=0;<\/p> <p>&nbsp; &nbsp; while(count!=strlen(T)&amp;&amp;i&lt;(strlen(S)))<\/p> <p>&nbsp; &nbsp; {<\/p> <p>&nbsp; &nbsp; &nbsp; &nbsp; if(S[i]==T[j])<\/p> <p>&nbsp; &nbsp; &nbsp; &nbsp; {<\/p> <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<\/p> <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<\/p> <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ',flagReadMore : '1',flagPrivate : '0',replyCount : '2',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '942479',postedTime : '1322200942',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/taozpwater', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=c8284969fc039245a5eba650f7a992f7/b58f8c5494eef01f31cfa761e0fe9925bd317dbe.jpg', portrait : '287d74616f7a7077617465722809', name : 'taozpwater' }, object : {type : 'text',id : '22a9be7145a9bf4dee1e5377',url : 'http:\/\/hi.baidu.com\/taozpwater\/item\/22a9be7145a9bf4dee1e5377',title : '弗洛伊德(Floyd)算法简介',summary : '<p>1、简介<\/p> <p>&nbsp; &nbsp; &nbsp; Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包，是一种动态规划算法。<\/p> <p>&nbsp; &nbsp; &nbsp;&nbsp;Floyd-Warshall算法的时间复杂度为O(N^3)，空间复杂度为O(N^2)。<\/p> <p>2、思路<\/p> <p>　 &nbsp;&nbsp;&nbsp;通过一个图的权值矩阵求出它的每两点间的最短路径矩阵。<\/p> <p>　　从图的带权邻接矩阵A=[a(i,j)] n×n开始，递归地进行n次更新，即由矩阵D(0)=A，按一个公式，构造出矩阵D(1)；又用同样地公式由D(1)构造出D(2)；……；最后又用同样的公式由D(n-1)构造出矩阵D(n)。矩阵D(n)的i行j列元素便是i号顶点到j号顶点的最短路径长度，称D(n)为图的距离矩阵，同时还可引入一个后继节点矩阵path来记录两点间的最短路径。<\/p> <p>　　采用的是(松弛技术)，对在i和j之间的所有其他点进行一次松弛。所以时间复杂度为O(n^3);<\/p> <p>　　其状态转移方程如下： map[i,j]:=min{map[i,k]+map[k,j],map[i,j]}<\/p> <p>　　map[i,j]表示i到j的最短距离<\/p> <p>　　K是穷举i,j的断点<\/p> <p>　　map[n,n]初值应该为0，或者按照题目意思来做。<\/p> <p>　　当然，如果这条路没有通的话，还必须特殊处理，比如没有map[i,k]这条路<\/p> <p>　　Floyd-Warshall算法的描述如下：<\/p> <p>　　for k ← 1 to n do<\/p> ',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '29462560',postedTime : '1321441988',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/mryuan0', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=5a7acdb809f79052eb4100617ccee1ff/8b82b9014a90f603095322ec3912b31bb151edbe.jpg', portrait : '77c26d727975616e303909', name : '袁大星' }, object : {type : 'text',id : 'b85ef9cac1e7d106ad092fcd',url : 'http:\/\/hi.baidu.com\/mryuan0\/item\/b85ef9cac1e7d106ad092fcd',title : '斐波那契数列的logn解法',summary : '<p>利用矩阵的表示方法，可以在logn的时间内计算斐波那契数列<\/p> <p>f(n+1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(n)<\/p> <p>f(n) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(n-1)<\/p> <p>利用这个公式，就可以计算出<\/p> <p>f(n+1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; ** n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f(1)&nbsp; &nbsp;<\/p> <p>f(n) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;1 &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(0)<\/p> <p>只需要求矩阵即可。<\/p> <p>利用分治策略即可。<\/p> ',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '29463035',postedTime : '1321436909',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/mryuan0', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=5a7acdb809f79052eb4100617ccee1ff/8b82b9014a90f603095322ec3912b31bb151edbe.jpg', portrait : '77c26d727975616e303909', name : '袁大星' }, object : {type : 'text',id : '62826af79667c6d76325d2cf',url : 'http:\/\/hi.baidu.com\/mryuan0\/item\/62826af79667c6d76325d2cf',title : '约瑟夫环',summary : '<p>The&nbsp;Josephus problem&nbsp;is defined as follows. Suppose that&nbsp;n&nbsp;people are arranged in a circle and that we are given a positive integer&nbsp;m&nbsp;≤&nbsp;n. Beginning with a designated first person, we proceed around the circle, removing every&nbsp;mth person. After each person is removed, counting continues around the circle that remains. This process continues until all&nbsp;n&nbsp;people have been removed. The order in which the people are removed from the circle defines the (n, m)-Josephus permutation&nbsp;of the integers 1, 2,...,&nbsp;n. For example, the (7, 3)-Josephus permutation is&nbsp;〈3, 6, 2, 7, 5, 1, 4〉.<\/p> <p>Suppose that&nbsp;m&nbsp;is a constant. Describe an&nbsp;O(n)-time algorithm that, given an integer&nbsp;n, outputs the (n,&nbsp;m)-Josephus permutation.<\/p> <p>Suppose that&nbsp;m&nbsp;is not a constant. Describe an&nbsp;O(n&nbsp;lg&nbsp;n)-time algorithm that, given integers&nbsp;n&nbsp;and&nbsp;m, outputs the (n,&nbsp;m)-Josephus permutation.<\/p> <p>a. Build a circle list of the n numbers, each has two fields, key being the number value and next pointer. The initialization takes O(n) time. We scan over the list, output every mth element and delete it from list till the list is empty. This process takes O(m) time per element, for a total time of O(mn). Since m is a constant, we get O(mn) = O(n) time.<\/p> <p>b. We use an order-statistic tree T , and we call the procedures OS-INSERT,<\/p> <p>OS-DELETE, OS-RANK, and OS-SELECT:<\/p> <p>JOSEPHUS(n,m)<\/p> <p>initiali<\/p> ',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '29462556',postedTime : '1321430541',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/mryuan0', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=5a7acdb809f79052eb4100617ccee1ff/8b82b9014a90f603095322ec3912b31bb151edbe.jpg', portrait : '77c26d727975616e303909', name : '袁大星' }, object : {type : 'text',id : 'd4636011acd4f69699ce33cd',url : 'http:\/\/hi.baidu.com\/mryuan0\/item\/d4636011acd4f69699ce33cd',title : '求最多重叠的点的问题 11-4',summary : '<p>Suppose that we wish to keep track of a&nbsp;point of maximum overlap&nbsp;in a set of intervals-a point that has the largest number of intervals in the database overlapping it.<\/p> <p>Show that there will always be a point of maximum overlap which is an endpoint of one of the segments.<\/p> <p>Design a data structure that efficiently supports the operations INTERVAL-INSERT, INTERVAL-DELETE, and FIND-POM, which returns a point of maximum overlap. (Hint:&nbsp;Keep a red-black tree of all the endpoints. Associate a value of +1 with each left endpoint, and associate a value of -1 with each right endpoint. Augment each node of the tree with some extra information to maintain the point of maximum overlap.)<\/p> <p>第一问的解答：<\/p> <p>Assume for the purpose of contradiction that there is no point of maximum<\/p> <p>overlap in an endpoint of a segment. The maximum overlap point p is in the<\/p> <p>interior of m segments. Actually, p is in the interior of the intersection of those<\/p> <p>m segments. Now look at one of the endpoints p of the intersection of the m<\/p> <p>segments. Point p has the same overlap as p because it is in the same intersec-<\/p> <p>tion of m segments, and so p is also a point of maximum overlap. Moreover, p<\/p> <p>is in the endpoint of a segment (otherwise the intersection would not end there),<\/p> <p>which contradicts our assumption that there is no point of maximum overlap in<\/p> <p>an endpoint of a segment. Thus, there is always a point of maximum overlap<\/p> <p>which is an endpoint of one of the segments<\/p> <p>第二',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '29463034',postedTime : '1321414232',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/mryuan0', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=5a7acdb809f79052eb4100617ccee1ff/8b82b9014a90f603095322ec3912b31bb151edbe.jpg', portrait : '77c26d727975616e303909', name : '袁大星' }, object : {type : 'text',id : 'dd7a5812dc34d8acfeded5cf',url : 'http:\/\/hi.baidu.com\/mryuan0\/item\/dd7a5812dc34d8acfeded5cf',title : '矩形重叠问题',summary : '<p>VLSI databases commonly represent an integrated circuit as a list of rectangles. Assume that each rectangle is rectilinearly oriented (sides parallel to the&nbsp;x- and&nbsp;y-axis), so that a representation of a rectangle consists of its minimum and maximum&nbsp;x- and&nbsp;y-coordinates. Give an&nbsp;O(n&nbsp;lg&nbsp;n)-time algorithm to decide whether or not a set of rectangles so represented contains two rectangles that overlap. Your algorithm need not report all intersecting pairs, but it must report that an overlap exists if one rectangle entirely covers another, even if the boundary lines do not intersect. (Hint:&nbsp;Move a &quot;sweep&quot; line across the set of rectangles.)<\/p> <p>General idea: Move a sweep line from left to right, while maintaining the set of<\/p> <p>rectangles currently intersected by the line in an interval tree. The interval tree<\/p> <p>will organize all rectangles whose x interval includes the current position of the<\/p> <p>sweep line, and it will be based on the y intervals of the rectangles, so that any<\/p> <p>overlapping y intervals in the interval tree correspond to overlapping rectangles.<\/p> <p>Details:<\/p> <p>1. Sort the rectangles by their x-coordinates. (Actually, each rectangle must ap-<\/p> <p>pear twice in the sorted list—once for its left x-coordinate and once for its right<\/p> <p>x-coordinate.)<\/p> <p>2. Scan the sorted list (from lowest to highest x-coordinate).<\/p> <p>&#8226;<\/p> <p>&#8226;<\/p> <p>When an x-coordinate of a left edge is found, check whether the rectangle’s<\/p> <p>y-coordinate interv<\/p> ',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '29462555',postedTime : '1321412740',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/mryuan0', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=5a7acdb809f79052eb4100617ccee1ff/8b82b9014a90f603095322ec3912b31bb151edbe.jpg', portrait : '77c26d727975616e303909', name : '袁大星' }, object : {type : 'text',id : 'fccc09f2d6d2e21fce9f32cd',url : 'http:\/\/hi.baidu.com\/mryuan0\/item\/fccc09f2d6d2e21fce9f32cd',title : 'MIN-GAP',summary : '<p>Show how to maintain a dynamic set&nbsp;Q&nbsp;of numbers that supports the operation MIN-GAP, which gives the magnitude of the difference of the two closest numbers in&nbsp;Q. For example, if&nbsp;Q&nbsp;= {1, 5, 9, 15, 18, 22}, then MIN-GAP(Q) returns 18 - 15 = 3, since 15 and 18 are the two closest numbers inQ. Make the operations INSERT, DELETE, SEARCH, and MIN-GAP as efficient as possible, and analyze their running times.<\/p> <p>这个题目的解答manual中有：<\/p> <p>Underlying data structure:<\/p> <p>A red-black tree in which the numbers in the set are stored simply as the keys<\/p> <p>of the nodes.<\/p> <p>S EARCH is then just the ordinary T REE -S EARCH for binary search trees, which<\/p> <p>runs in O(lg n) time on red-black trees.<\/p> <p>2. Additional information:<\/p> <p>The red-black tree is augmented by the following fields in each node x:<\/p> <p>min-gap[x] contains the minimum gap in the subtree rooted at x. It has the<\/p> <p>magnitude of the difference of the two closest numbers in the subtree rooted<\/p> <p>at x. If x is a leaf (its children are all nil[T ]), let min-gap[x] = ∞.<\/p> <p>min-val[x] contains the minimum value (key) in the subtree rooted at x.<\/p> <p>max-val[x] contains the maximum value (key) in the subtree rooted at x.<\/p> <p>Maintaining the information:<\/p> <p>The three Telds added to the tree can each be computed from information in the<\/p> <p>node and its children. Hence by Theorem 14.1, they can be maintained during<\/p> <p>insertion and deletion without affecting the O(lg n) running time:<\/p> <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp<\/p> ',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}},{id : '29463031',postedTime : '1321325178',flagRepost : '0',flagReply : '0',flagEdit : '0',flagError : '0',flagOnWall : '0',flagPubSource : '1',actor : { qingUrl : '\/mryuan0', avatar : 'http://hiphotos.baidu.com/space/scrop=65;q=100/sign=5a7acdb809f79052eb4100617ccee1ff/8b82b9014a90f603095322ec3912b31bb151edbe.jpg', portrait : '77c26d727975616e303909', name : '袁大星' }, object : {type : 'text',id : 'e51077102e9f1ee29813d6cf',url : 'http:\/\/hi.baidu.com\/mryuan0\/item\/e51077102e9f1ee29813d6cf',title : '求后序遍历的序列是否正确',summary : '<p>第9 题<\/p> <p>判断整数序列是不是二元查找树的后序遍历结果<\/p> <p>题目：输入一个整数数组，判断该数组是不是某二元查找树的后序遍历的结果。<\/p> <p>如果是返回true，否则返回false。<\/p> <p>例如输入5、7、6、9、11、10、8，由于这一整数序列是如下树的后序遍历结果<\/p> <p>8<\/p> <p>\/ \\<\/p> <p>6 10<\/p> <p>\/ \\ \/ \\<\/p> <p>5 7 9 11<\/p> <p>因此返回true。<\/p> <p>如果输入7、4、6、5，没有哪棵树的后序遍历的结果是这个序列，因此返回false。<\/p> <p>这个题目是一个递归问题<\/p> <p>最后一个节点是根节点，前面所有比根节点小的节点是左子树， 比根节点大的都是右子树的节点，<\/p> <p>这样就转换为两个子问题。<\/p> <p>下面是别人给出的一个解法。<\/p> <p>在后续遍历得到的序列中，最后一个元素为树的根结点。从头开始扫描这个序列，比根结点小的元素都应该位于序列的左半部分；从第一个大于跟结点开始到跟结点前面的一个元素为止，所有元素都应该大于跟结点，因为这部分元素对应的是树的右子树。根据这样的划分，把序列划分为左右两部分，我们递归地确认序列的左、右两部分是不是都是二元查找树。&nbsp;<\/p> <p>参考代码：&nbsp;<\/p> <p>C++代码<\/p> <p>using&nbsp;namespace&nbsp;std; &nbsp;&nbsp;<\/p> <p>\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/&nbsp;&nbsp;&nbsp;<\/p> <p>\/\/ Verify whether a squence of integers are the post order traversal&nbsp;&nbsp;&nbsp;<\/p> <p>\/\/ of a<\/p> ',flagReadMore : '1',flagPrivate : '0',replyCount : '0',repostCount : '0',number : '0',tags : [{name : '算法导论',namePath : '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'}],attachments : []}} ]};	</script><script src="http://hi.bdimg.com/static/qcenter/js/feed/feed_import.js?v=db615d47.js"></script><script>wpo.head=new Date*1;</script> </head> <body>  <header class=mod-topbar id=modTopbar><iframe class=mod-topbar-bgframe></iframe><div class=mod-topbar-pseudo-real><div class="wrapper-box clearfix"><div class=left-box><a href="http://hi.baidu.com" class=logo-box><span id=baiduSpaceLogo class=q-logo></span></a></div><div class=center-box><ul class=q-menubox><li class=q-menuitem><a href="http://hi.baidu.com/tag" >推荐</a></ul></div><div class=right-box><ul class=q-navbox><li class=q-navitem><a href="http://hi.baidu.com/go/login" class=q-goto-login>登录</a><li class="q-navitem q-nav-sp"><span></span><li class=q-navitem><a href="http://hi.baidu.com/go/reg">注册</a> </ul></div></div></div></header>   <section class=mod-page-body> <div class="mod-page-main wordwrap clearfix">  <div class=x-page-container><section class=mod-main-box><div class=mod-page-bg-wraper><div id=qcenterBody class="grid-98 mod-main-wraper clearfix"><div id=yyAdvLink></div><div class="grid-75 left"><section id=ent class="mod-ent-wraper clearfix"> <div class="mod-ent clearfix"> <div class="ent-tag clearfix"> <div class="ent-tagname-container left"> <span class=tagname>算法导论</span>  <span class="follow-btn hide" id=tagFollowBtn><span class=state-icon></span><span class=state-word>订阅</span></span> <span class="followed-btn" id=tagFollowedBtn><span class=state-icon></span><span class=state-word>已订阅</span></span>  </div> <div class="ent-link-container right">    </div> </div> </div> <div class=ent-shadow></div></section><script>
(function(){
    var followstatus = '';
    var tagName = '算法导论';
    var tagNameHtml = '算法导论';
    var tagNameUrl = '%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA';
    var followbtn = T.g("tagFollowBtn");
    var unfollowbtn = T.g("tagFollowedBtn");

    var tagItemTpl = [
        '<div class="tag-item" onmouseover="qing.QTag.feedList.onTagOver(this)" onmouseout="qing.QTag.feedList.onTagOut(this)">',
            '<div class="tag-box-border">',
                '<a class="tag-box" href="#{tagUrl}">',
                    '<div class="tag-shodow-box">',
                        '<div class="tag-wraper clearfix">',
                            '<div class="tag-icon"></div>',
                            '<em class="tag-name selected">#{tagName}</em>',
                        '</div>',
                    '</div>',
                '</a>',
            '</div>',
        '</div>'
    ].join('');
    if(followbtn!=null && unfollowbtn!=null){
        initFollow();
        initUnfollow();
    }

    function addFollowedItem(){
        var item = tagItemTpl.replace('#{tagUrl}', "/tag/"+tagNameUrl+"/feeds").replace('#{tagName}', tagNameHtml);
        qing.dom.insertHTML(qing.dom.query('.tag-list')[0], "afterBegin", item);
        var thisitem = qing.dom.query('.tag-list .tag-item')[0];
        var d = qext.fn.getDimensions(thisitem);
        qing.dom.query('.mod-side-tags .tag-title')[0].innerHTML = "我订阅的标签";
        thisitem.style.height = "0px";
        var animer = qani.animate(thisitem, {height:0+"px"}, {height : d.height+"px$tween:strongAc2deCelerate"},600);
    }

    function deleteFollowedItem(){
        var items = qing.dom.query('.tag-list .tag-item');
        qing.array.each(items, function(item, index){
            var itemName = qing.dom.query('.tag-name', item)[0];
            if(itemName.innerHTML.toLowerCase() == tagNameHtml.toLowerCase()){
                var d = qext.fn.getDimensions(item);
                var animer = qani.animate(item, {height:d.height+"px"}, {height : 0+"px$tween:strongAc2deCelerate"},600);
                animer.on("finish", function(){
                    qing.dom.remove(item);
                    if(items.length==1){
                        qing.dom.query('.mod-side-tags .tag-title')[0].innerHTML = "";
                    }
                });
            }
        });

    }
    

    function initUnfollow(){
        T.event.on(unfollowbtn, "mouseover", function(){
            T.dom.removeClass(unfollowbtn, "followed-btn");
            T.dom.addClass(unfollowbtn, "tofollow-btn");
            T.dom.query(".state-word", unfollowbtn)[0].innerHTML = "取消订阅";
        });

        T.event.on(unfollowbtn, "mouseout", function(){
            T.dom.removeClass(unfollowbtn, "tofollow-btn");
            T.dom.addClass(unfollowbtn, "followed-btn");
            T.dom.query(".state-word", unfollowbtn)[0].innerHTML = "已订阅";
        });

        T.event.on(unfollowbtn, "click", function(){
            qing.ajax.post("/tag/submit/unfollowtag", {'tagname':tagName}, function(xhr, response){
                qui.showSuccess("取消订阅成功");
                T.dom.removeClass(followbtn,"hide");
                T.dom.addClass(unfollowbtn, "hide");
                deleteFollowedItem();
            });
        });
    }

    function initFollow(){
        T.event.on(followbtn, "click", function(){
            if(!qing.QTag.Common.checkLogin()){
                return;
            }
            qing.ajax.post("/tag/submit/followtag", {'tagname':tagName}, function(xhr, response){
                qui.showSuccess("订阅成功");
                T.dom.removeClass(unfollowbtn,"hide");
                T.dom.addClass(followbtn, "hide");
            });
            addFollowedItem();
        });
    }
})()
</script><section class=mod-feed-main-content id=feedMainContent><div class="mod-new-feed-box hide" id=newFeedBox></div><div class=mod-feed-list-box id=feedListBox></div><div class=mod-feed-load-tip id=feedLoadTip><div class=feed-layout-wraper><div class=loading-icon></div><div class=tip-content>正在加载内容，请稍侯...</div></div></div></section><script>
	(function(){
		//加载事件监听管理器
		feedOptions = {
			hostPortrait	: qUserInfo.portrait || '1aeb73706163655f7465737430323206',
			tags : ['%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA'],
			emptyTip : '此标签下暂时没有文章，看看其他<a href="/tag">热门标签</a>',
						param : {
			   	'goto' : 'new'
			}
					};
				feedMain.perShowNum = 10;
		feedMain.perLoadNum = 30;
				feedMain.startId = '1329048107';
		feedMain.endId = '1321325178';
		feedMain.dataSource = qDomain.qing + '/tag/data/feedlist';
		feedMain.initPage(feedOptions);
		
		//启动新Feed监听
		//feedMain.runNewFeedListener();

		//图片延迟加载初始化
		//qext.lazy.ImageLoad.init();
	})();
</script><script src="http://hi.bdimg.com/static/qcenter/js/feed/feed_listener_manager.js?v=b4fc0e17.js"></script><script>
	QingFeed.ListenerMgr.run();
</script><script src="http://hi.bdimg.com/static/qcomment/js/qcmt_import.js?v=4e210ca1.js"></script></div><div class="grid-23 right"><div class=mod-side-wraper><div class=mod-side-box><div class=side-mini-solid-border></div><section class="mod-side-item mod-side-radio"><div id=sideRadio></div></section><script type="text/javascript">qing.registNS("radio");radio=(function(){var b=['<div class="mod-radio-wraper">','<div class="radio-box clearfix">','<div class="radio-content-box" style="height:#{radioImgHeight}px;">','<div class="radio-content-border-right" style="height:#{radioImgHeight}px;"></div>','<div class="radio-control-box">','<a href="#" id="prevRadioBt" class="prev-bt">上一个</a>','<a href="#" id="nextRadioBt" class="next-bt">下一个</a>',"</div>",'<div class="radio-scroll-wraper" style="height:#{radioImgHeight}px;">','<div class="radio-scroll-box" style="margin-top:0px;">',"#{imgListTpl}","</div>","</div>",'<div class="radio-content-border-left" style="height:#{radioImgHeight}px;margin-top:-#{radioImgHeight}px;"></div>','<div class="radio-content-border-top" style="top:-#{radioImgHeight}px;"></div>','<div class="radio-content-border-bottom"></div>',"</div>","</div>",'<div class="radio-actor-box">',"#{actorListTpl}","</div>","</div>"].join("");var d=['<a class="radio-img-wraper" href="#{imgUrl}" style="height:#{imgHeight}px" title="#{imgDesc}" target="_blank">','<img class="radio-img" style="width:#{imgWidth}px;height:#{imgHeight}px" src="#{imgSrc}" alt="#{imgDesc}"/>',"</a>"].join("");var c=['<div class="radio-actor-item clearfix" data-userid="#{dataUserid}">','<a class="radio-actor-img" href="#{actorUrl}" target="_blank">','<img src="#{actorImgSrc}" alt="#{actorName}"/>',"</a>",'<div class="radio-actor-info">','<em class="radio-actor-name">#{actorName}</em>','<div class="radio-follow-box">#{actorFollow}</div>',"</div>","</div>"].join("");var a='<a href="#" class="radio-addfollow-bt">关注</a>';var g='<span class="radio-followed">已关注</span>';var e=function(h){qing.ajax.get(qDomain.qing+"/home/data/radio",function(K){var D=K[0];if(!D||!D[0]){return}var k=265;var C=207;var i=D[0];var L=D[D.length-1];var o=[];qing.array.each(D,function(N,M){o.push(qing.string.format(d,{imgUrl:N.object.url,imgHeight:N.object.img.height||k,imgWidth:C,imgSrc:N.object.img.src,imgDesc:N.object.desc}))});var E=[];qing.array.each(D,function(N,M){o.push(qing.string.format(d,{imgUrl:N.object.url,imgHeight:N.object.img.height||k,imgWidth:C,imgSrc:N.object.img.src,imgDesc:N.object.desc}));E.push(N.actor.id)});qing.ajax.request(qDomain.qing+"/home/data/usercard",{method:"get",noCache:true,data:{ids:E.join(",")},onsuccess:function(N){if(N&&N[0]&&N[0][0]){var M=N[0];qing.array.each(M,function(P,O){D[O].flagFollow=P.flagFollow})}}});var y=qing.string.format(c,{dataUserid:i.actor.id,actorUrl:i.actor.url,actorImgSrc:i.actor.imgSrc,actorName:i.actor.name});h.innerHTML=qing.string.format(b,{imgListTpl:o.join(""),actorListTpl:y,radioImgHeight:i.object.img.height||k,lastRadioHeight:L.object.img.height||k});var w=0;var x=0;var q=qing.g("prevRadioBt");var F=qing.g("nextRadioBt");var I=qing.dom.query(".radio-scroll-box",h)[0];var B=qing.dom.query(".radio-control-box")[0];var u=qing.dom.query(".radio-scroll-wraper",h)[0];var H=qing.dom.query(".radio-content-box",h)[0];var A=qing.dom.query(".radio-content-border-top",h)[0];var j=qing.dom.query(".radio-content-border-left",h)[0];var l=qing.dom.query(".radio-content-border-right",h)[0];var m=qing.dom.query(".radio-content-border-bottom",h)[0];var G=qing.dom.query(".radio-actor-box",h)[0];B.style.display="none";B.style.display="block";var r=false;function p(P){if(D.length==1){return}if(r){return}if(!qani){return}r=true;var R;var M=qing.dom.query(".radio-img-wraper",h);if(P=="next"){var V=M[w];if(w==D.length-1){var Q=M[0];var N=M[M.length-1];qing.dom.insertAfter(Q,N);I.style.marginTop=(parseInt(I.style.marginTop)+parseInt(Q.style.height))+"px";R=Q}else{w++;R=M[w]}var T=qani.animate(I,{"margin-top":(parseInt(I.style.marginTop)-parseInt(V.style.height))+"px$tween:decelerate"},300);T.on("finish",function(){r=false});x=(x+1)%D.length}else{var V=M[w];if(w==0){var Q=M[0];var N=M[M.length-1];qing.dom.insertBefore(N,Q);I.style.marginTop=(parseInt(I.style.marginTop)-parseInt(N.style.height))+"px";R=N}else{w--;R=M[w]}var T=qani.animate(I,{"margin-top":(parseInt(I.style.marginTop)+parseInt(R.style.height))+"$tween:decelerate"});T.on("finish",function(){r=false},300);x=x==0?D.length-1:x-1}var S=R.style.height;u.style.height=S;H.style.height=S;l.style.height=S;j.style.height=S;j.style.marginTop="-"+S;A.style.top="-"+S;var U=D[x];var O=qing.string.format(c,{dataUserid:U.actor.id,actorUrl:U.actor.url,actorImgSrc:U.actor.imgSrc,actorName:U.actor.name});G.innerHTML=O}qing.event.on(q,"click",function(M){qing.event.preventDefault(M);p("prev")});qing.event.on(F,"click",function(M){qing.event.preventDefault(M);p("next")});function n(){return setInterval(function(){p("next")},5000)}var J=n();var z=qing.dom.query(".radio-box",h)[0];var v=null;qing.event.on(z,"mouseover",function(M){qing.event.preventDefault(M);if(J){clearInterval(J);J=null}v=qani.animate(B,{"margin-left":qing.browser.ie<=7?207:209},300)});qing.event.on(z,"mouseout",function(M){qing.event.preventDefault(M);(!J)&&(J=n());v.destroy();v=qani.animate(B,{"margin-left":165},300)});var t=qing.dom.query(".radio-actor-box",h)[0];var s;qing.event.on(t,"mouseover",function(R){qing.event.stop(R);if(s){clearTimeout(s);s=null;return}var O=qing.dom.query(".radio-follow-box",t)[0];var T=qing.dom.query(".radio-actor-item",t)[0];for(var N=0,M=D.length;N<M;N++){var P=D[N];if(P.actor.id==qing.dom.getAttr(T,"data-userid")){if(qVisitorInfo.portrait==P.actor.id){break}if(typeof P.flagFollow!="undefined"){O.innerHTML=parseInt(P.flagFollow)==1?g:a;O.style.display="block";var S=qing.dom.query(".radio-addfollow-bt",O);if(S&&(S=S[0])){var Q=qing.dom.query(".radio-actor-name",O)[0];qing.event.on(S,"click",function(U){qing.event.preventDefault(U);qing.ajax.post(qDomain.qing+qVisitorInfo.qingUrl+"/qfriend/submit/addcare",{uname:P.actor.name},function(V){O.innerHTML=g;P.flagFollow=1})})}}break}}});qing.event.on(t,"mouseout",function(M){qing.event.stop(M);s=setTimeout(function(){var N=qing.dom.query(".radio-follow-box",t)[0];N.style.display="none";s=null},50)})})};var f=function(){try{qing.event.on(window,"load",function(){e(qing.g("sideRadio"))})}catch(h){}};return{init:f}})();radio.init();</script></div></div> </div> </div></div></section> </div> </div> </section>  <footer class=mod-footer><div class="clearfix hidden-box"></div><div class=footer-box><div class=inner-box><a href="http://hi.baidu.com/go/show/introduce" target=_blank>帮助中心</a><span>&nbsp;|&nbsp;</span><a href="http://tieba.baidu.com/f?kw=%B0%D9%B6%C8%BF%D5%BC%E4&fr=wwwt" target=_blank>空间客服</a><span>&nbsp;|&nbsp;</span><a href=http://tousu.baidu.com/hi/add target=_blank>投诉中心</a><span>&nbsp;|&nbsp;</span><a href=http://www.baidu.com/search/hi_contract.html target=_blank>空间协议</a></div><div class=copy-box>&copy;2012&nbsp;Baidu</div></div></footer>  <script src="http://hi.bdimg.com/static/qbase/js/mod/mod_foot.js?v=5c26d90d.js"></script>  <script>		(function(){			qing.dom.ready(function(){				qext.back2top.init({                    left:510                });			});		})();	</script> <script>wpo.tti=new Date*1;</script><script>document.write(unescape("%3Cscript src='http://hm.baidu.com/h.js%3F8c869b543955d43e496c2efee5b55823' type='text/javascript'%3E%3C/script%3E"));</script>