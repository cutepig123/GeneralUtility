<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>[算法导论读书笔记]二项堆 -  - 博客频道 - CSDN.NET</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="二项树的定义：二项树Bk是一种递归定义的有序树，如下图所示。二项树B0只包含一个节点。二项树Bk由两棵二项树Bk-1连接而成。其中一棵树的根是另一棵树的根的最左孩子。下图所示的是二项堆，二项堆链接了三个二项树（B0&#160;B2&#160;B4&#160;）。二项树的性质：1.共有2k个节点。2.树的高度为k4.根的度数为k，它大于任何其他节点的度数；并且，如果根的" />
<script src="http://static.blog.csdn.net/Scripts/jquery.js" type="text/javascript"></script>
<script src="http://static.blog.csdn.net/scripts/plugins.js" type="text/javascript"></script>
<script src="http://static.blog.csdn.net/scripts/common.js" type="text/javascript"></script>
<link rel="Stylesheet" type="text/css" href="http://static.blog.csdn.net/skin/light_blue/css/style.css" />
<link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="/lalor/rss/list" />
<link rel="shortcut icon" href="/favicon.ico" />
<link type="text/css" rel="stylesheet" href="http://static.blog.csdn.net/scripts/SyntaxHighlighter/styles/simple.css" />
</head>
<body>
<script src="http://csdnimg.cn/pubnav/js/pub_topnav_2011.js"type="text/javascript"></script>
<div id="container">
<div id="header">
    <div class="header">
        <div id="blog_title">
            <h1>
                <a href="/lalor"></a></h1>
            <h2>Nothing replaces hard work</h2>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>
            <!--<li id="btnHome"><a href="/lalor"><span><img src="http://static.blog.csdn.net/images/ico_home.gif">我的首页</span></a></li>-->
            <li id="btnContents"><a href="/lalor?viewmode=contents"><span><img src="http://static.blog.csdn.net/images/ico_list.gif">目录视图</span></a></li>
            <li id="btnView"><a href="/lalor?viewmode=list"><span><img src="http://static.blog.csdn.net/images/ico_summary.gif">摘要视图</span></a></li>
            <li id="btnRss"><a href="/lalor/rss/list"><span><img src="http://static.blog.csdn.net/images/ico_rss.gif">订阅</span></a></li>
</ul>
    </div>
</div>
<script type="text/javascript">
    var username = "lalor";
    var blog_address = "http://blog.csdn.net/lalor";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = $.cookie("UserName");
</script>
        
<div id="body">
<div id="main">
<div class="main">
<div class="notice"> 


<a href="http://cloud.csdn.net/a/20120620/2806805.html" target="_blank"><font color=red>用开源IaaS构建自己的云——OpenStack征稿启事
</font></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://adclk.thinkmedia.cn/clk/pid=2000/media=CSDN.CN/place=1Clt1/size=760x90" target="_blank"><font color=blue>不用买彩票，就有408万！</font></a>
<br>
<a href="http://blog.csdn.net/blogdevteam/article/details/7608507" target="_blank"><font color=blue>CSDN博客频道“移动开发之我见”主题征文活动 </font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://blog.csdn.net/blogdevteam/article/details/7666263" target="_blank"><font color=red> 2012CSDN网站八大职位急聘</font></a>


</div><script type="text/javascript" src="http://static.blog.csdn.net/scripts/ad.js"></script>

<div id="article_details" class="details">
    <div class="article_title">
    <span class="ico ico_type_Original"></span>
    <h3>
        <span class="link_title"><a href="/lalor/article/details/7384745">
        [算法导论读书笔记]二项堆
        </a></span>
    </h3>
</div>

        
    <div class="article_manage">
        <span class="link_categories">
        分类：
            <a href="/lalor/article/category/899960">算法</a> 
        </span>
    <span class="link_postdate">2012-03-22 21:03</span>
    <span class="link_view" title="阅读次数">185人阅读</span>
    <span class="link_comments" title="评论次数"><a href="#comments">评论</a>(0)</span>
    <span class="link_collect"><a href="javascript:void(0);" onclick="javascript:collectArticle('[算法导论读书笔记]二项堆','7384745');return false;" title="收藏">收藏</a></span>
    <span class="link_report"><a href="#report"  onclick="javascript:report(7384745,2);return false;" title="举报">举报</a></span>
    
</div>

    
<div id="article_content" class="article_content">
    
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'Times New Roman'"><strong>二项树的定义：</strong></span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-size:16px"><span style="font-family:'Times New Roman'">二项树</span><span style="font-family:'DejaVu Serif'">B</span><span style="font-family:'DejaVu Serif'; vertical-align:sub">k</span><span style="font-family:'Times New Roman'">是一种递归定义的有序树，如下图所示。二项树</span><span style="font-family:'DejaVu Serif'">B</span><span style="font-family:'DejaVu Serif'; vertical-align:sub">0</span><span style="font-family:'Times New Roman'">只包含一个节点。二项树</span><span style="font-family:'DejaVu Serif'">B</span><span style="font-family:'DejaVu Serif'; vertical-align:sub">k</span><span style="font-family:'Times New Roman'">由两棵二项树</span><span style="font-family:'DejaVu Serif'">B</span><span style="font-family:'DejaVu Serif'; vertical-align:sub">k-1</span><span style="font-family:'Times New Roman'">连接而成。其中一棵树的根是另一棵树的根的最左孩子。下图所示的是二项堆，二项堆链接了三个二项树（<span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'">B</span><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub">0</span></span><span style="font-family:'DejaVu Serif'">&nbsp;<span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'">B2</span>&nbsp;<span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'">B4</span>&nbsp;</span><span style="font-family:'Times New Roman'">）。</span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'Times New Roman'"><img src="http://hi.csdn.net/attachment/201203/22/0_1332419689X086.gif" alt=""><br>
</span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'Times New Roman'"><br>
</span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'Times New Roman'"><strong>二项树的性质：</strong></span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'DejaVu Serif'">1.</span><span style="font-family:'Times New Roman'">共有</span><span style="font-family:'DejaVu Serif'">2</span><span style="font-family:'DejaVu Serif'; vertical-align:super">k</span><span style="font-family:'Times New Roman'">个节点。</span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'DejaVu Serif'">2.</span><span style="font-family:'Times New Roman'">树的高度为</span><span style="font-family:'DejaVu Serif'">k</span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'DejaVu Serif'">4.</span><span style="font-family:'Times New Roman'">根的度数为</span><span style="font-family:'DejaVu Serif'">k</span><span style="font-family:'Times New Roman'">，它大于任何其他节点的度数；并且，如果根的子女从左到右编号为</span><span style="font-family:'DejaVu Serif'">k-1</span><span style="font-family:'Times New Roman'">，</span><span style="font-family:'DejaVu Serif'">k-1</span><span style="font-family:'Times New Roman'">，<span style="font-family:Times New Roman">……</span><span style="font-family:宋体">，</span></span><span style="font-family:'DejaVu Serif'">0</span><span style="font-family:'Times New Roman'">，子女</span><span style="font-family:'DejaVu Serif'">i</span><span style="font-family:'Times New Roman'">是子树</span><span style="font-family:'DejaVu Serif'">B</span><span style="font-family:'DejaVu Serif'; vertical-align:sub">i</span><span style="font-family:'Times New Roman'">的根。</span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'Times New Roman'">推论：在一颗包含</span><span style="font-family:'DejaVu Serif'">n</span><span style="font-family:'Times New Roman'">个节点的二项树中，任意节点的最大度数为</span><span style="font-family:'DejaVu Serif'">lg</span><span style="font-family:'DejaVu Serif'">n</span><span style="font-family:'Times New Roman'">。</span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'Times New Roman'"><br>
</span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'Times New Roman'"><strong>二项堆的定义：</strong></span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'DejaVu Serif'">1.H</span><span style="font-family:'Times New Roman'">中的每个二项树遵循最小堆性质：节点的关键字大于或等于其父节点的关键字。我们说这种树是最小堆有序的。</span><span style="font-family:'Times New Roman'"></span></span></p>
<p class="p0" style="font-family:arial; line-height:23px; margin-bottom:0pt; margin-top:0pt">
<span style="font-size:16px"><span style="font-family:'DejaVu Serif'">2.</span><span style="font-family:'Times New Roman'">对任意非负整数</span><span style="font-family:'DejaVu Serif'">k</span><span style="font-family:'Times New Roman'">，在</span><span style="font-family:'DejaVu Serif'">H</span><span style="font-family:'Times New Roman'">中至多有一棵二项树的根具有度数</span><span style="font-family:'DejaVu Serif'">k</span><span style="font-family:'Times New Roman'">。</span></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px">&nbsp; &nbsp; 由上图可知，二项堆中每个节点都有至少3个指针域（指向父亲，孩子，兄弟），一个degree，标识有几个孩子，一个key，用于存储数据，还可以包含其他卫星数据。</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px"><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px"><strong>创建一个新的二项堆：</strong></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px">&nbsp; &nbsp; 为了构造一个空的二项堆，过程MAKE_BINOMIAL_HEAP分配并返回一个对象H，且head[H]=NIL。该过程的运行时间复杂度为O(1)。</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px"><strong>寻找最小关键字：</strong></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px">&nbsp; &nbsp; 过程BINOMIAL_HEAP_MINIMUM(H)返回一个指针，它指向包含n个节点的二项堆H中具有最小关键子的节点。因为一个二项堆是几个最小堆链接起来的，所以，最小关键字必在根节点中。伪代码如下：</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_1332420023FSm7.gif" alt=""><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px">&nbsp; &nbsp; 因为至多要检查|_lgn_| &#43; 1 个根，故BINOMIAL_HEAP_MINIMUM的运行时间为O(lgn)。</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px"><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px"><strong>合并两个二项堆：</strong></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px">&nbsp; &nbsp; 合并两个二项堆的操作可用作后面大部分操作的一个子程序。过程BINOMIAL_HEAP_UNION反复链接根节点的度数相同的各二项树。在下面的过程中，将以节点y为根的<span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'">B</span><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub">k-1树与节点z为根的<span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'">B</span><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub">k-1树连接起来；亦即，它使得z是y的父节点，并成为一颗<span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'">B</span><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub">k树的根。</span></span></span></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px"><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub"><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub"><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub"><img src="http://hi.csdn.net/attachment/201203/22/0_1332420355IkLI.gif" alt=""><br>
</span></span></span></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'Times New Roman'; font-size:16px"><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub"><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub"><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub"><br>
</span></span></span></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">&nbsp; &nbsp; 下面的过程合并二项堆H1和H2，并返回结果堆。在合并过程中，它同时破坏了H1，H2的表示。除了BINOMIAL——LINK之外，这个过程还使用了一个辅助过程BINOMIAL_HEAP_MERGE，来将H1和H2的根表合并成一个按度数的单调递增次序排列的链表。伪代码如下：</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_1332420700d9bb.gif" alt=""><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">合并过程中会遇到4中情况：</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">case1，正是我们所期望的那样，继续往后遍历。</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">case2，连续三个度数相同的二项树，转换成case3、4</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">case3，合并两个<span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'">B</span><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub">k-1</span>
 到<span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'">B</span><span style="line-height:23px; font-size:16px; font-family:'DejaVu Serif'; vertical-align:sub">k</span>&nbsp;其中key[x]&lt;= key[next_x]</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">case4，如case3，不过有key[next_x] &gt; key[x]，且需要注意prev_x=NIL的情况。</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">下面是合并H1和H2的一个图形化示例：</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_133242072714Xa.gif" alt=""><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_13324207479KNS.gif" alt=""><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><strong>插入一个节点：</strong></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_1332420822087a.gif" alt=""><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">&nbsp; &nbsp; 这个过程先在O(1)的时间内，构造一个包含一个节点的二项堆H‘，再在O(lgn)时间内，将其与包含n个节点的二项堆H合并。对BINOMIAL_HEAP_UNION的调用还负责释放临时二项堆H‘。</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><strong>抽取具有最小关键字的节点：</strong></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_13324210380DN6.gif" alt=""><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">&nbsp; &nbsp; 这个过程的工作如下图所示。因为如果H有n个节点，则第1——4行每次需要时间O(lgn)。所以，BINOMIAL_HEAP_EXTRACT_MIN的运行时间为O(lgn)。</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_1332421068kHTP.gif" alt=""></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><strong>减小关键字的&#20540;：</strong></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">&nbsp; &nbsp; 首相将关键字的&#20540;减少为新的&#20540;，然后调整二项树（向上调），使其满足而项树的要求。</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_1332421068kHTP.gif" alt=""><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><strong>删除一个关键字：</strong></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px">&nbsp; &nbsp; 很容易在O(lgn)时间内从二项堆H中删除一个节点x。先将要删除的关键字的&#20540;改为最小的关键字。然后提取最小关键字节点。这样就很轻松的删除了一个节点。易知，过程BINOMIAL_HEAP_DELETE的时间为O(lgn).</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><img src="http://hi.csdn.net/attachment/201203/22/0_1332421318Ymm9.gif" alt=""><br>
</span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"><strong>代码示例：</strong></span></p>
<p class="p0" style="line-height:23px; margin-bottom:0pt; margin-top:0pt"><span style="font-family:'DejaVu Serif'; font-size:16px"></span><textarea readonly name="code" class="cpp">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
using namespace std;
const int neg_inf = -1000000;//negative infinity
const int pos_inf = 1000000;//postive infinity

struct _node
{
	int key; //键
	int degree;//度数，也就是孩子的个数
	struct _node *p;//指向父亲的指针
	struct _node *child;//指向孩子的指针
	struct _node *sibling;//指向兄弟的指针
};
	
typedef struct _node node;
typedef struct _node * pnode;

// find the least element's value
pnode BINOMIAL_HEAP_MININUM( pnode H )
{
	pnode y = NULL;
	pnode x = H;
	int min = pos_inf;
	while( x != NULL )
	{
		if( x-&gt;key &lt; min )
		{
			min = x-&gt;key;
			y = x;
		}
		x = x-&gt;sibling;
	}
	return y;
}

// new a node
pnode MAKE_BINOMIAL_HEAP()
{
	pnode temp = (pnode)malloc(sizeof(node));
	temp-&gt;key = 0;
	temp-&gt;degree = 0;
	temp-&gt;p = NULL;
	temp-&gt;child = NULL;
	temp-&gt;sibling = NULL;
	return temp;
}

// link y to z as left child
bool BINOMIAL_LINK( pnode y, pnode z)
{
	y-&gt;p = z;
	y-&gt;sibling = z-&gt;child;
	z-&gt;child = y;
	z-&gt;degree++;
	return true;
}

//union two linked list
pnode BINOMIAL_HEAP_MERGE( pnode H1, pnode H2)
{
	//assert( H1 &amp;&amp; H2 );
	if( H1 == NULL )
	{
		return H2;
	}
	if( H2 == NULL )
	{
		return H1;
	}
	pnode H = NULL;
	pnode r = NULL;
	pnode p = H1, q = H2;

	if( p-&gt;degree &lt; q-&gt;degree)
	{
		H = p;
		p = p-&gt;sibling;
	}
	else
	{
		H = q;
		q = q-&gt;sibling;
	}

	r = H;

	while( p != NULL &amp;&amp; q != NULL )
	{
		if( p-&gt;degree &lt;= q-&gt;degree)
		{
			r-&gt;sibling = p;
			r = p;
			p = p-&gt;sibling;
		}	
		else
		{
			r-&gt;sibling = q;
			r = q;
			q = q-&gt;sibling;
		}				
	}

	while( p != NULL )
	{
		r-&gt;sibling = p;
		r = p;
		p = p-&gt;sibling;
	}

	while( q != NULL )
	{
		r-&gt;sibling = q;
		r = q;
		q = q-&gt;sibling;
	}
	return H;
}


//Union two binary heap
pnode BINOMIAL_HEAP_UNION(pnode H1, pnode H2)
{
	pnode H;
	H = BINOMIAL_HEAP_MERGE( H1, H2);
	if( H == NULL )
	{
		return NULL;
	}

	pnode prev_x = NULL;
	pnode x = H;
	pnode next_x = x-&gt;sibling;

	while( next_x != NULL )
	{
		if(( x-&gt;degree != next_x-&gt;degree ) || (next_x-&gt;sibling != NULL &amp;&amp; next_x-&gt;sibling-&gt;degree == x-&gt;degree ) )//case1, 2
		{
			prev_x = x;
			x = next_x;
		}
		else if( x-&gt;key &lt;= next_x-&gt;key)//case3
		{
			x-&gt;sibling = next_x-&gt;sibling;
			BINOMIAL_LINK(next_x, x);
		}
		else//case4
		{
			if( prev_x == NULL )
			{
				H = next_x;
			}
			else
			{
				prev_x-&gt;sibling = next_x;
			}
			BINOMIAL_LINK(x, next_x);
			x = next_x;	
		}
		next_x = x-&gt;sibling;	
	}
	return H;
}


//insert a element to head
pnode BINOMIAL_HEAP_INSERT( pnode H, int x)
{
	pnode HH = MAKE_BINOMIAL_HEAP();
	HH-&gt;degree = 0;
	HH-&gt;key = x;
	HH-&gt;sibling = NULL;
	HH-&gt;p = NULL;
	HH-&gt;child = NULL;
	
	return BINOMIAL_HEAP_UNION( H, HH);
}

//reverse a linked list
pnode reverse( pnode H )
{
	if( H == NULL )
	{
		return NULL;
	}
	
	pnode p = H;
	pnode q = H-&gt;sibling;
	pnode r;
	p-&gt;sibling = NULL;
	while( q != NULL )
	{
		r = q-&gt;sibling;
		q-&gt;sibling = p;
		p = q;
		q = r;
	}
	return p;	
}


//extract the least element , and use the second argument to storage the element.
pnode BINOMIAL_HEAP_EXTRACT_MIN( pnode H, struct _node **p)
{
	if( H == NULL )
	{
		return NULL;
	}
	pnode y = NULL;
	pnode prev_y = NULL;
	pnode possible_prev_y = NULL;
	pnode x = H;

	pnode H1 = NULL;
	int min = pos_inf;
	while( x != NULL )
	{
		if( x-&gt;key &lt; min )
		{
			min = x-&gt;key;
			prev_y = possible_prev_y;
			y = x;
		}
		possible_prev_y = x;
		x = x-&gt;sibling;
	}

	if( prev_y == NULL )
	{
		H = y-&gt;sibling;
	}
	else
	{
		prev_y-&gt;sibling = y-&gt;sibling;
	}

	H1 = y-&gt;child;

	H1 = reverse( H1 ); 
	*p = y;
	return  BINOMIAL_HEAP_UNION(H, H1);	
}

//change the goal element to negative infinity, then, extract the least element.
pnode BINOMIAL_HEAP_DELETE(pnode H, pnode x)
{
	H = BINMIAL_HEAP_DECREASE_KEY( H, x, neg_inf);
	H = BINOMIAL_HEAP_EXTRACT_MIN(H, &amp;x);
	free(x);
	x = NULL;
	return H;
}

//decreast x'value to key
pnode BINOMIAL_HEAP_DECREASE_KEY(pnode H, pnode x, int k)
{
	if( k &gt; x-&gt;key )
	{
		cout &lt;&lt; &quot;new key is greater than current key&quot; &lt;&lt; endl;
		return H;
	}
	
	x-&gt;key = k;
	pnode y = x;
	pnode z = y-&gt;p;	
	while( z != NULL &amp;&amp; y-&gt;key &lt; z-&gt;key )
	{
		//swap y and z
		int temp = y-&gt;key;
		y-&gt;key = z-&gt;key;
		z-&gt;key = y-&gt;key;

		y = z;
		z = y-&gt;p;
	}	
	
	return H;	
}
int main(int argc, char* argv[])
{
	pnode head = NULL;
	pnode x;
	head = BINOMIAL_HEAP_INSERT(head, 9);
	head = BINOMIAL_HEAP_INSERT(head, 4);
	head = BINOMIAL_HEAP_INSERT(head, 5);
	head = BINOMIAL_HEAP_INSERT(head, 6);
	head = BINOMIAL_HEAP_INSERT(head, 7);
	head = BINOMIAL_HEAP_INSERT(head, 8);
	head = BINOMIAL_HEAP_INSERT(head, 3);
	cout &lt;&lt; BINOMIAL_HEAP_MININUM( head )-&gt;key &lt;&lt; endl;

	head = BINOMIAL_HEAP_EXTRACT_MIN(head, &amp;x);
	cout &lt;&lt; x-&gt;key &lt;&lt; endl;
	free(x);
	x = NULL;

	head = BINOMIAL_HEAP_EXTRACT_MIN(head, &amp;x);
	cout &lt;&lt; x-&gt;key &lt;&lt; endl;
	free(x);
	x = NULL;

	head = BINOMIAL_HEAP_EXTRACT_MIN(head, &amp;x);
	cout &lt;&lt; x-&gt;key &lt;&lt; endl;
	free(x);
	x = NULL;

	cout &lt;&lt; BINOMIAL_HEAP_MININUM( head )-&gt;key &lt;&lt; endl;
	return 0;
}</textarea><br>
<br>
</p>

</div>
<div class="share_buttons" id="sharePanel"></div>

<div class="article_next_prev">
        <li class="prev_article">
            <span>上一篇：</span><a href="http://blog.csdn.net/lalor/article/details/7380708">图的广度优先搜索</a></li>
        <li class="next_article">
            <span>下一篇：</span><a href="http://blog.csdn.net/lalor/article/details/7388476">Depth First Traversal for a graph</a></li>
</div>


        <div id="digg" ArticleId="7384745">
            <dl id="btnDigg" class="digg digg_disable">
                <dt>顶</dt>
                <dd>0</dd>
            </dl>
            <dl id="btnBury" class="digg digg_disable">
                <dt>踩</dt>
                <dd>0</dd>
            </dl>
        </div>
</div>
<div id="ad_cen"></div>
<script type="text/javascript">
    new Ad(4, 'ad_cen');
</script>
<div id="comment_title" class="panel_head">查看评论<a name="comments"></a></div>
<div id="comment_list"></div>
<div id="comment_bar"></div>
<div id="comment_form"></div>
<div class="announce">* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
<script type="text/javascript">
    var fileName = '7384745';
    var commentscount = 0;
    var islock = false
</script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/comment.js?v=1.1"></script>
<div id="ad_bot"></div>
<script type="text/javascript">
    new Ad(5, 'ad_bot');
</script>
<div id="report_dialog"></div>


<div class="clear"></div>
</div>
</div>
<div id="side">
    <div class="side">
<div id="panel_Profile" class="panel">
    <ul class="panel_head"><span>个人资料</span></ul>
    <ul class="panel_body profile">
        <div id="blog_userface">
            <a href="http://my.csdn.net/lalor" target="_blank">
            <img src="http://avatar.csdn.net/F/B/9/1_lalor.jpg" title="访问我的空间" style="max-width:90%"/>
            </a>
            <br />
            <span><a href="http://my.csdn.net/lalor" target="_blank">lalor</a></span>
        </div>
<div class="interact">
<!--<a href="#" class="attented" title="已关注"></a>-->
<a href="#" class="attent" id="span_add_follow" title="[加关注]"></a>
<a href="http://my.csdn.net/my/letter/send/lalor" class="letter" title="[发私信]"></a>
</div>
        <div id="blog_medal">
        </div>
        <ul id="blog_rank">
            <li>访问：<span>29294次</span></li>
            <li>积分：<span>1880分</span></li>
            <li>排名：<span>第2905名</span></li>
        </ul>
        <ul id="blog_statistics">
            <li>原创：<span>152篇</span></li>
            <li>转载：<span>40篇</span></li>
            <li>译文：<span>7篇</span></li>
            <li>评论：<span>34条</span></li>
        </ul>
    </ul>
</div>

<script type='text/javascript'>
var _blogger='lalor';
$(document).ready(function () {
    $('#span_add_follow').click(function () {
        var url = "http://my.csdn.net/index.php/follow/do_follow?jsonpcallback=?";
        $.getJSON(url, { "username": _blogger }, function (data) {
            if (data.succ == 1) {
                alert('关注成功！');
                $('#span_add_follow').attr('class', 'attented').click(function () { return false; });
            } else {
                alert(data.msg);
            }
        });
    });
    if (getUN().toLowerCase() == _blogger.toLowerCase()) {
        $('.interact').hide();
    }
});
function getUN() {
    var m = document.cookie.match(new RegExp("(^| )UserName=([^;]*)(;|$)"));
    if (m) return m[2];
    else return '';
}
</script>

<div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search" target="_blank">
        <span><input id="inputSearch" type="text" class="blogsearch" title="请输入关键字" /></span>
        <input id="btnSubmit" type="submit" value="搜索" title="search in blog" />
        <input type="hidden" name="q" id="inputQ" />
        <input type="hidden" name="t" value="blog" />
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div><div id="custom_column_21081256" class="panel">
    <ul class="panel_head"><span>声明</span></ul>
    <ul class="panel_body">
        
<font color="ff0000"><b>本博客乃学习笔记，没有纯粹无意义的转载。作者除了对自己负责，不对任何读者负责。欢迎指出文章错误，如果原意交朋友，可以通过Gmail联系我（mingxinglai#gmail.com），博主是男的^_^</b></font>

    </ul>
</div><div id="panel_Category" class="panel">
    <ul class="panel_head"><span>文章分类</span></ul>
    <ul class="panel_body">
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/894485">C++/C</a><span>(29)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/899960">算法</a><span>(39)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/1079528">Unix系统编程</a><span>(9)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/894032">OJ</a><span>(26)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/899289">VC/MFC</a><span>(21)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/899961">笔试面试</a><span>(34)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/900038">linux/shell</a><span>(22)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/938322">STL</a><span>(5)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/900041">IT杂文</a><span>(9)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/1079527">编程珠玑</a><span>(8)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/944193">Qt</a><span>(4)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/1135966">Python</a><span>(0)</span>
        
        </li>
        <li>
        <a href="http://blog.csdn.net/lalor/article/category/1135967">vim</a><span>(5)</span>
        
        </li>
    </ul>
</div><div id="panel_Archive" class="panel">
    <ul class="panel_head"><span>文章存档</span></ul>
    <ul class="panel_body">
        <div id="archive_list">
        <!--归档统计-->
        <li><a href="http://blog.csdn.net/lalor/article/month/2012/06">2012年06月</a>(16)</li><li><a href="http://blog.csdn.net/lalor/article/month/2012/05">2012年05月</a>(24)</li><li><a href="http://blog.csdn.net/lalor/article/month/2012/04">2012年04月</a>(12)</li><li><a href="http://blog.csdn.net/lalor/article/month/2012/03">2012年03月</a>(49)</li><li><a href="http://blog.csdn.net/lalor/article/month/2012/02">2012年02月</a>(30)</li><li><a href="http://blog.csdn.net/lalor/article/month/2011/12">2011年12月</a>(5)</li><li><a href="http://blog.csdn.net/lalor/article/month/2011/11">2011年11月</a>(21)</li><li><a href="http://blog.csdn.net/lalor/article/month/2011/10">2011年10月</a>(37)</li><li><a href="http://blog.csdn.net/lalor/article/month/2011/09">2011年09月</a>(4)</li>
        </div>
    </ul>
</div>
<div id="hotarticls" class="panel">
    <ul class="panel_head"><span>阅读排行</span></ul>
    <ul class="panel_body">
        <li>
            <a href="/lalor/article/details/6845788" title="深度优先遍历算法的非递归实现">深度优先遍历算法的非递归实现</a> (752)
        </li>
        <li>
            <a href="/lalor/article/details/6912274" title="MFC对话框画图">MFC对话框画图</a> (583)
        </li>
        <li>
            <a href="/lalor/article/details/6908382" title="MFC连接mysql数据库（十分钟搞定）">MFC连接mysql数据库（十分钟搞定）</a> (506)
        </li>
        <li>
            <a href="/lalor/article/details/6863681" title="一道有趣的面试题——将int型数组强制转换为char*，再求strlen，涉及大小端">一道有趣的面试题——将int型数组强制转...</a> (451)
        </li>
        <li>
            <a href="/lalor/article/details/7025239" title="interfaceX is on channel Y, but the AP uses channel Z">interfaceX is on cha...</a> (424)
        </li>
        <li>
            <a href="/lalor/article/details/7277761" title="vim宏录制">vim宏录制</a> (411)
        </li>
        <li>
            <a href="/lalor/article/details/7314134" title="线性规划之单纯型算法">线性规划之单纯型算法</a> (330)
        </li>
        <li>
            <a href="/lalor/article/details/7430631" title="求两个链表的并集和交集">求两个链表的并集和交集</a> (325)
        </li>
        <li>
            <a href="/lalor/article/details/7318401" title="字符串匹配之Rabin-Karp算法">字符串匹配之Rabin-Karp算法</a> (315)
        </li>
        <li>
            <a href="/lalor/article/details/7393381" title="[算法导论读书笔记]Prim算法">[算法导论读书笔记]Prim算法</a> (295)
        </li>
    </ul>
</div>
<div id="hotarticls" class="panel">
    <ul class="panel_head"><span>评论排行</span></ul>
    <ul class="panel_body">
        <li>
            <a href="/lalor/article/details/7284967" title="[编程珠玑读书笔记]快速排序">[编程珠玑读书笔记]快速排序</a> (9)
        </li>
        <li>
            <a href="/lalor/article/details/7400690" title="[算法导论读书笔记]Dijkstra算法">[算法导论读书笔记]Dijkstra算法</a> (4)
        </li>
        <li>
            <a href="/lalor/article/details/6863681" title="一道有趣的面试题——将int型数组强制转换为char*，再求strlen，涉及大小端">一道有趣的面试题——将int型数组强制转...</a> (4)
        </li>
        <li>
            <a href="/lalor/article/details/7631243" title="[编程之美]设计一个高效的数据结构，尽可能快的返回队列中的最大值">[编程之美]设计一个高效的数据结构，尽可...</a> (3)
        </li>
        <li>
            <a href="/lalor/article/details/6931275" title="迪杰斯特拉算法">迪杰斯特拉算法</a> (2)
        </li>
        <li>
            <a href="/lalor/article/details/6912274" title="MFC对话框画图">MFC对话框画图</a> (2)
        </li>
        <li>
            <a href="/lalor/article/details/7521005" title="测试管道的容量">测试管道的容量</a> (2)
        </li>
        <li>
            <a href="/lalor/article/details/7284569" title="[编程珠玑读书笔记] 插入排序">[编程珠玑读书笔记] 插入排序</a> (2)
        </li>
        <li>
            <a href="/lalor/article/details/7370542" title="[算法导论读书笔记]堆排序，优先队列">[算法导论读书笔记]堆排序，优先队列</a> (2)
        </li>
        <li>
            <a href="/lalor/article/details/7339992" title="[算法导论读书笔记]装配线调度问题">[算法导论读书笔记]装配线调度问题</a> (2)
        </li>
    </ul>
</div>
<div id="homepageArticles" class="panel">
    <ul class="panel_head"><span>推荐文章</span></ul>
    <ul class="panel_body" id="ad_commend"></ul>
</div>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/ad.js"></script>
<script type="text/javascript">
    new Ad(12, 'ad_commend');
</script><div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body">
    <li>
    <a href="/lalor/article/details/6931275#comments">迪杰斯特拉算法</a>
    <p style="margin:0px;">Consolesolo:
Mark
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/7339992#comments">[算法导论读书笔记]装配线调度问题</a>
    <p style="margin:0px;">lalor:
@liuning800203:vim+gcc，vim写代码超快，极力推荐。
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/7339992#comments">[算法导论读书笔记]装配线调度问题</a>
    <p style="margin:0px;">liuning800203:
你好，问下，你是用什么编译代码的
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/7631243#comments">[编程之美]设计一个高效的数据结构，尽可能快的返回队列中的最大值</a>
    <p style="margin:0px;">wyhhxx17:
这不就是优先队列这个ADT的API吗，就是返回优先级最大的，和实现没关系啊。
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/7631243#comments">[编程之美]设计一个高效的数据结构，尽可能快的返回队列中的最大值</a>
    <p style="margin:0px;">lalor:
@wyhhxx17:恩，是我说得不是很清楚，不知道你说的优先队列是不是的STL中的priority_...
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/7631243#comments">[编程之美]设计一个高效的数据结构，尽可能快的返回队列中的最大值</a>
    <p style="margin:0px;">wyhhxx17:
请问这个问题有点奇怪啊，直接说实现一个优先队列不就行了，还这样绕着讲话？？？？？
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/6912274#comments">MFC对话框画图</a>
    <p style="margin:0px;">CXPUU:
顶
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/7366962#comments">clock,clock_t,times的注意事项</a>
    <p style="margin:0px;">yangruibao:
怎么变成比较的是clock和time，而不是clock和times的差别？
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/6912274#comments">MFC对话框画图</a>
    <p style="margin:0px;">hy09070422:
网上很少有原创的东西，带实例的就更少了，虽然没看懂。顶下。
    </p>
    </li>
    <li>
    <a href="/lalor/article/details/6931275#comments">迪杰斯特拉算法</a>
    <p style="margin:0px;">lidonglong121:
感谢博主~
    </p>
    </li>
</ul>
</div>
    </div>
    <div class="clear">
    </div>
</div>

<div class="clear"></div>
</div>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/SyntaxHighlighter/shCore-src.js"></script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.js"></script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/article_code.js"></script>

<script type="text/javascript" src="http://medal.blog.csdn.net/scripts/show.js"></script>
<script type="text/javascript" src="http://medal.blog.csdn.net/showblogmedal.ashx?blogid=1146542"></script>
<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script>
<script type="text/javascript" src="http://csdnimg.cn/pubfooter/js/publib_footer.js"></script>

<script type="text/javascript" src="http://www.csdn.net/ui/scripts/Csdn/counter.js"></script>


</div>
</body>
</html>